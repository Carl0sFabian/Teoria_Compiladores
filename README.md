<div style="width: 100%; clear: both;">
<div style="float: left; width: 50%;">
<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ45DITH77up1n8tb7Bx2n7TO8tBq4I65ZIuw&s", align="left">
</div>
<div style="float: right; width: 50%;">
<p style="margin: 0; padding-top: 22px; text-align:right;">1ACC0218-2520-1733 - Teor√≠a de Compiladores </p>
<p style="margin: 0; text-align:right;">2025 ¬∑ Compilador</p> 
<p style="margin: 0; text-align:right;">Prof: <b>Peter Jonathan Montalvo Garcia</b></p>
<p style="margin: 0; text-align:right; padding-button: 100px;">Integrante 1: <b>Mendoza Quispe Carlos Fabian  </b> - <a href="">U20231C416@upc.edu.pe</a></p>
<p style="margin: 0; text-align:right; padding-button: 100px;">Integrante 2: <b>Ibarra Cabrera Camila Adriana </b> - <a href="">U202317287@upc.edu.pe</a></p>
<p style="margin: 0; text-align:right; padding-button: 100px;">Integrante 3: <b>Rojas S√°nchez Patricia Luc√≠a del Rosario</b> - <a href="">U202310474@upc.edu.pe</a></p>
</div>
</div>
<div style="width:100%;">&nbsp;</div>
<center><h1>üìô Introducci√≥n</h1></center>
El pensamiento computacional es una habilidad crucial y fundamental para la programaci√≥n moderna, ya que dota a los individuos de capacidades esenciales como el pensamiento cr√≠tico, la abstracci√≥n y el razonamiento algor√≠tmico necesarias para la formulaci√≥n de soluciones √≥ptimas a problemas complejos, tanto dentro como fuera del √°mbito inform√°tico; sin embargo, a pesar de su reconocida importancia, persisten serias dificultades en la ense√±anza de la programaci√≥n, inherentes a su complejidad t√©cnica y a la falta de desarrollo de estas habilidades clave, donde la tendencia actual, amplificada por la influencia de la IA, prioriza la generaci√≥n de c√≥digo funcional complejo sobre el dominio de los fundamentos l√≥gicos y algor√≠tmicos, dejando a menudo a los programadores principiantes o inexpertos sin una base s√≥lida; por esta raz√≥n, es imperativo reenfocar el aprendizaje de la programaci√≥n desde sus etapas iniciales hacia la l√≥gica y el pensamiento computacional, lo que no solo facilitar√° la comprensi√≥n clara y accesible de los fundamentos, sino que tambi√©n proporcionar√° a los estudiantes una base robusta que les permitir√° trascender las reglas espec√≠ficas de un lenguaje para aplicar principios generales en diversos contextos, promoviendo una crucial adaptabilidad y prepar√°ndolos efectivamente para enfrentar nuevas tecnolog√≠as, herramientas y paradigmas de la programaci√≥n.

<div style="width:100%;">&nbsp;</div>
<center><h1>üí™ Problem√°tica y motivaci√≥n </h1></center>

El pensamiento computacional es una habilidad fundamental que todo ser humano debe desarrollar, ya que implica un conjunto de capacidades esenciales para la programaci√≥n. La resoluci√≥n de problemas, tanto computacionales como no computacionales, requiere de habilidades como el pensamiento cr√≠tico, el razonamiento compositivo, la coincidencia de patrones y el pensamiento procedimental, entre otras, para formular soluciones √≥ptimas (Leticia y Norka, 2021). En particular, en la programaci√≥n, es crucial que los estudiantes, y cualquier persona interesada en aprender sobre el tema, desarrollen el pensamiento algor√≠tmico y la capacidad de abstracci√≥n. Estas habilidades son claves para resolver problemas de manera eficiente, estructurada y optimizada.

Pese a que, cada vez se reconoce con mayor vigor la importancia del pensamiento l√≥gico computacional en la programaci√≥n, todav√≠a persisten dificultades inherentes a la complejidad t√©cnica y a la falta de habilidades para la resoluci√≥n de problemas. En el contexto actual, con la creciente influencia de la Inteligencia Artificial, conceptos como el pensamiento cr√≠tico, la abstracci√≥n y el dise√±o algor√≠tmico est√°n poco desarrollados (Vera et al., 2025). En cambio, se prioriza la generaci√≥n de c√≥digo funcional, que a menudo involucra operaciones matem√°ticas complejas y algoritmos avanzados, alejados del nivel de conocimiento del programador, especialmente si este es principiante o cuenta con poca experiencia en el tema.

Esta situaci√≥n se ve agravada por la forma en que tradicionalmente se ense√±a la programaci√≥n. Delgadillo y Ruiz (2021) encontraron que, aunque los estudiantes de Inform√°tica Administrativa reconocen la importancia de la programaci√≥n para el desarrollo de sistemas de informaci√≥n y aplicaciones, la mayor√≠a se siente neutral o inseguro al enfrentarse a la codificaci√≥n, especialmente en sus primeros semestres. Esta inseguridad se debe, en parte, a que la ense√±anza no siempre conecta la l√≥gica algor√≠tmica con contextos reales ni aprovecha herramientas que reduzcan la carga cognitiva inicial.
Adem√°s, Ayala Cadena y Aguilar Ju√°rez (2023) destacan que los estudiantes de nuevo ingreso se enfrentan a un reto de alta complejidad: deben aprender definiciones t√©cnicas abstractas, desarrollar algoritmos sin experiencia previa y comprender lenguajes de programaci√≥n, todo ello sin el apoyo constante de un docente fuera del aula. En este escenario, el uso de software educativo especializado y agentes conversacionales puede actuar como puente, facilitando la autogesti√≥n del aprendizaje y reforzando la comprensi√≥n de la l√≥gica subyacente.

Por ello, es fundamental hacer √©nfasis en la l√≥gica y el pensamiento computacional desde las primeras etapas del aprendizaje de la programaci√≥n. Este enfoque no solo ayudar√° a los estudiantes a comprender los fundamentos de la programaci√≥n de manera clara y accesible, sino que tambi√©n les proporcionar√° una base s√≥lida sobre la cual podr√°n construir habilidades m√°s avanzadas. Al dominar la l√≥gica y pensamiento algor√≠tmico, el estudiante no se ver√° limitado por las reglas espec√≠ficas de un lenguaje, sino que podr√° comprender c√≥mo aplicar principios generales en diferentes contextos (Barrag√°n, 2023). Este enfoque no solo facilita el aprendizaje de nuevos lenguajes, sino que tambi√©n promueve una adaptabilidad duradera frente a las nuevas tecnolog√≠as, herramientas y paradigmas de programaci√≥n.
Esta necesidad cobra especial relevancia en el contexto peruano, donde el Programa Nacional de Becas y Cr√©dito Educativo (Pronabec) impulsa el acceso a carreras t√©cnicas de alta demanda, como la programaci√≥n. Tal como lo destacan los talentos becarios de Beca 18, la programaci√≥n ofrece alta demanda laboral, r√°pida inserci√≥n profesional y flexibilidad modal, incluyendo trabajo remoto (Pronabec, 2022). Sin embargo, como afirma una becaria: ‚ÄúNo importa d√≥nde vives, ni tu g√©nero, ni tu edad, solo necesitas voluntad, disciplina y pasi√≥n‚Äù (Pronabec, 2022). Pero incluso con motivaci√≥n, la barrera inicial de la sintaxis y la abstracci√≥n puede ser insuperable sin herramientas pedag√≥gicas adecuadas.

Es en este escenario donde proponemos NumLang: un lenguaje de dominio espec√≠fico (DSL) minimalista, dise√±ado expresamente para algoritmos num√©ricos y l√≥gica b√°sica, con una sintaxis cercana a la notaci√≥n matem√°tica natural. NumLang busca reducir la fricci√≥n cognitiva al eliminar la sobrecarga sint√°ctica innecesaria, permitiendo que los estudiantes se enfoquen en la l√≥gica del algoritmo, no en la gram√°tica del lenguaje. Adem√°s, como componente pedag√≥gico, el compilador incluir√° un m√≥dulo que traduce el c√≥digo fuente a descripciones en lenguaje natural, reforzando la comprensi√≥n del flujo de ejecuci√≥n

<div style="width:100%;">&nbsp;</div>
<center><h1>üéØ Objetivo </h1></center>

- **Objetivo general**

Dise√±ar e implementar un DSL minimalista que permite expresar operaciones matem√°ticas, condicionales y bucles con la menor sintaxis posible, y que sea capaz de compilar a c√≥digo ejecutable eficiente mediante LLVM, con soporte adicional para generar descripciones en lenguaje natural con fines pedag√≥gicos.

- **Objetivos espec√≠ficos**

    - Definir una gram√°tica formal en ANTLR4 que soporte operaciones matem√°ticas, estructuras condicionales y bucles con sintaxis minimalista y cercana al lenguaje matem√°tico natural.

    - Implementar un frontend en Python (lexer y parser mediante ANTLR4) capaz de construir un √Årbol Sint√°ctico Abstracto (AST) a partir de programas escritos en el DSL.

    - Desarrollar un backend que genere c√≥digo intermedio de LLVM a partir del AST, produciendo un ejecutable funcional para algoritmos num√©ricos b√°sicos.

    - Crear un m√≥dulo pedag√≥gico que traduzca el AST a descripciones en lenguaje natural, reforzando la comprensi√≥n del flujo de ejecuci√≥n. (Ejemplo: convertir "x = 5" en "se asigna 5 a la variable x".)


<div style="width:100%;">&nbsp;</div>
<center><h1>üë• Integrantes </h1></center>
Los integrantes para el desarrollo del proyecto son los siguientes:

<table>
  <thead>
    <tr>
      <th scope="col">N√∫mero</th>
      <th scope="col">Integrante</th>
      <th scope="col">Correo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Alexandra Fong Saravia</td>
      <td>U202216001@upc.edu.pe</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Camila Adriana Ibarra Cabrera</td>
      <td>U202317287@upc.edu.pe</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Carlos Fabian Mendoza Quispe</td>
      <td>U20231C416@upc.edu.pe</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Patricia Luc√≠a del Rosario Rojas S√°nchez</td>
      <td>U202310474@upc.edu.pe</td>
    </tr>
  </tbody>
</table>


<center><h1>‚úçüèª Arquitectura del compilador </h1></center>
<img src="./img/arquitectura-compilador.png", align="left">

<center><h1>üìÅ Descripci√≥n de la aplicaci√≥n con contenedores </h1></center>

### 1. Clonar la imagen a utilizar para el contenedor

```bash
docker pull petermontalvo09/llvm:1.0.0
```  

### 2. Crear y ejecutar el contenedor
```bash
docker run --name trabajo-final-contenedor -it 
```
```bash
docker start -ai trabajo-final-contenedor
```

### 3. Crear los archivos a utilizar
```bash
touch CMakeLists.txt
touch CodeGen.h
touch CodeGen.cpp
touch MiniCVisitorLLVM.h
touch MiniCVisitorLLVM.cpp
touch main.cpp
```

### 4. Limpiar compilaciones previas
```bash
rm -rf build
```

### 5. Ejecutar ANTLR
```bash
antlr4 -Dlanguage=Cpp -visitor MiniC.g4
```

### 6. Ingresar programa de c√≥digo fuente
```bash
mkdir build && cd build
cmake ..
make -j
touch EjemplosMiniC.mc
```

### 7. Compilar el programa
```bash
./minic EjemplosMiniC.mc
clang out.ll -o out_exec
```

### 8. Ejecutar el programa
```bash
./out_exec
```

### 7. Resultado de la ejecuci√≥n
C√≥digo fuente del ejemplo en *EjemplosMiniC.mc*
<img src="./img/ejemplo1.png">

Resultado del ejemplo en *EjemplosMiniC.mc*
<img src="./img/ejemplo1_res.png">